package com.gemsrobotics.lib.subsystems.drivetrain;

import com.gemsrobotics.lib.physics.MotorTransmission;
import com.gemsrobotics.lib.math.se2.RigidTransform;
import com.gemsrobotics.lib.math.se2.Rotation;
import com.gemsrobotics.lib.math.se2.Twist;
import com.gemsrobotics.lib.utils.FastDoubleToString;

import java.util.Arrays;
import java.util.function.DoubleFunction;

import static com.gemsrobotics.lib.utils.MathUtils.epsilonEquals;
import static com.gemsrobotics.lib.utils.MathUtils.kEpsilon;
import static com.gemsrobotics.lib.utils.MathUtils.Bounds;
import static java.lang.Math.*;

public class Model {
	public static class Properties {
		// Mass of the robot, kg
		public double mass;

		// Moment of inertia around the center of mass, around the z-axis, kg*m^2.
		public double momentInertia;

		// Modelled as a constant for the total torque on the drivetrain (CCW)
		// generated by CCW motion in (N*m)/(rad/s). Torque = angular_drag*omega.
		// This constant should be negative.
		public double angularDrag;

		// The radius of the wheel in meters.
		public double wheelRadius;

		// Effective wheelbase radius, meters. Slightly larger than actual due to skid.
		public double wheelbaseRadius;

		public double wheelCircumference() {
		    return PI * 2 * wheelRadius;
        }
	}

	public static class Dynamics {
		public double curvature = 0.0;
		public double dcurvature = 0.0;

		public ChassisState chassisVelocity = new ChassisState();
		public ChassisState chassisAcceleration = new ChassisState();

		public WheelState wheelVelocity = new WheelState();
		public WheelState wheelAcceleration = new WheelState();

		public WheelState voltage = new WheelState();
		public WheelState torque = new WheelState();
	}

	// Can refer to velocity or acceleration depending on context.
	public static class ChassisState {
		public double linear;
		public double angular;

		public ChassisState(double linear, double angular) {
			this.linear = linear;
			this.angular = angular;
		}

		public ChassisState() {
			this(0, 0);
		}

		@Override
		public String toString() {
			return "[" + FastDoubleToString.format(linear, 3) + ", " + FastDoubleToString.format(angular, 3) + "]";
		}
	}

	// Can refer to getVelocity, getAcceleration, torque, voltage, etc., depending on context.
	public static class WheelState {
		public double left;
		public double right;

		public WheelState(double left, double right) {
			this.left = left;
			this.right = right;
		}

		public WheelState() {
			this(0, 0);
		}

		public WheelState(final WheelState other) {
		    this(other.left, other.right);
        }

		public WheelState copy() {
			return new WheelState(left, right);
		}

		public WheelState map(final DoubleFunction<Double> f) {
		    return new WheelState(f.apply(left), f.apply(right));
        }

		public WheelState inverse() {
		    return map(n -> -n);
        }

        public WheelState sum(final WheelState other) {
		    return new WheelState(left + other.left, right + other.right);
        }

        public WheelState difference(final WheelState other) {
		    return sum(other.inverse());
        }

		public void flip() {
			final var tempL = left;
			left = -right;
			right = -tempL;
		}

		@Override
		public String toString() {
			return "[" + FastDoubleToString.format(left, 2) + ", " + FastDoubleToString.format(right, 2) + "]";
		}
	}

	public final double wheelBaseRadius, angularDrag, mass, momentInertia, wheelRadius;
	public final MotorTransmission transmissionLow, transmissionHigh;

	// two-speed drive train
	public Model(
			final Properties properties,
			final MotorTransmission gearLow,
			final MotorTransmission gearHigh
	) {
		wheelBaseRadius = properties.wheelbaseRadius;
		angularDrag = properties.angularDrag;
		mass = properties.mass;
		momentInertia = properties.momentInertia;
		wheelRadius = properties.wheelRadius;

		transmissionLow = gearLow;
		transmissionHigh = gearHigh;
	}

	private MotorTransmission getTransmission(final boolean isHighGear) {
	    if (isHighGear) {
            return transmissionHigh;
        } else {
            return transmissionLow;
        }
    }

	// single speed drive train
	public Model(final Properties properties, final MotorTransmission transmission) {
		this(properties, transmission, transmission);
	}

	// Left/right to linear/angular (wheel)
	// Input/demand could be either getVelocity or getAcceleration...the math is the same.
	public ChassisState forwardKinematics(final WheelState wheels) {
		return new ChassisState(
				(wheels.left + wheels.right) / 2 * wheelRadius,
				(wheels.right - wheels.left) / (2 * wheelBaseRadius) * wheelRadius
		);
	}

	/**
	 * Forward kinematics using only encoders, rotation is implicit (less accurate than below, but useful for predicting
	 * motion)
	 */
	public Twist forwardKinematics(final double leftDelta, final double rightDelta) {
		final var thetaDelta = (rightDelta - leftDelta) / wheelBaseRadius;
		return forwardKinematics(leftDelta, rightDelta, thetaDelta);
	}

	/**
	 * Forward kinematics using encoders and explicitly measured rotation (ex. from gyro)
	 */
	public Twist forwardKinematics(final double leftDelta, final double rightDelta, final double thetaDelta) {
		final var dx = (leftDelta + rightDelta) / 2;
		return new Twist(dx, 0.0, thetaDelta);
	}

	/**
	 * For convenience, forward kinematics with an absolute rotation and previous rotation.
	 */
	public Twist forwardKinematics(
			final Rotation previousHeading,
			final double leftDelta,
			final double rightDelta,
			final Rotation currentHeading
	) {
		return forwardKinematics(leftDelta, rightDelta, currentHeading.difference(previousHeading).getRadians());
	}

	public RigidTransform solveForwardKinematics(final RigidTransform currentPose, final Twist delta) {
		return currentPose.transformBy(delta.toRigidTransform());
	}

	public RigidTransform solveForwardKinematics(
			final RigidTransform currentPose,
			final double leftDelta,
			final double rightDelta,
			final Rotation currentHeading
	) {
		final var withGyro = forwardKinematics(currentPose.getRotation(), leftDelta, rightDelta, currentHeading);
		return solveForwardKinematics(currentPose, withGyro);
	}

	// Linear/angular (m/s) to left/right (rads/s)
	// Input/demand could be either velocity or acceleration...the math is the same.
	public WheelState inverseKinematics(final ChassisState chassis) {
		return new WheelState(
				(chassis.linear - chassis.angular * wheelBaseRadius) / wheelRadius,
				(chassis.linear + chassis.angular * wheelBaseRadius) / wheelRadius
		);
	}

	// Linear/angular velocity and left/right voltage to linear/angular acceleration
	public Dynamics solveForwardDynamics(final ChassisState velocity, final WheelState voltage, final boolean isHighGear) {
		final var transmission = getTransmission(isHighGear);

		final var ret = new Dynamics();

		ret.wheelVelocity = inverseKinematics(velocity);
		ret.chassisVelocity = velocity;
		ret.voltage = voltage;

		// not moving, and not giving enough torque to start moving
		final boolean stuckLeft = epsilonEquals(ret.wheelVelocity.left, 0) && abs(voltage.left) < transmission.stictionVoltage;
		final boolean stuckRight = epsilonEquals(ret.wheelVelocity.right, 0) && abs(voltage.right) < transmission.stictionVoltage;

		if (stuckLeft && stuckRight) {
			return ret;
		}

		ret.curvature = ret.chassisVelocity.angular / ret.chassisVelocity.linear;

		if (Double.isNaN(ret.curvature)) {
			ret.curvature = 0.0;
		}

		ret.torque = new WheelState(
				transmission.torqueForVoltage(ret.wheelVelocity.left, voltage.left),
				transmission.torqueForVoltage(ret.wheelVelocity.right, voltage.right)
		);

		ret.chassisAcceleration.linear = (ret.torque.left + ret.torque.right) / (wheelRadius * mass);
		ret.chassisAcceleration.angular = wheelBaseRadius * (ret.torque.right - ret.torque.left)
											  / (wheelRadius * momentInertia) - (velocity.angular * angularDrag / momentInertia);

		ret.dcurvature = (ret.chassisAcceleration.angular - ret.chassisAcceleration.linear * ret.curvature) /
								  (ret.chassisVelocity.linear * ret.chassisVelocity.linear);

		if (Double.isNaN(ret.dcurvature)) {
			ret.dcurvature = 0.0;
		}

		ret.wheelAcceleration.left = ret.chassisAcceleration.linear - ret.chassisAcceleration.angular * wheelBaseRadius;
		ret.wheelAcceleration.right = ret.chassisAcceleration.linear + ret.chassisAcceleration.angular * wheelBaseRadius;

		return ret;
	}

	public Dynamics solveForwardDynamics(final WheelState velocity, final WheelState voltage, final boolean isHighGear) {
		return solveForwardDynamics(forwardKinematics(velocity), voltage, isHighGear);
	}

	// Linear/angular getVelocity and linear/angular getAcceleration to left/right voltage
	public Dynamics solveInverseDynamics(final ChassisState velocity, final ChassisState acceleration, final boolean isHighGear) {
		final var transmission = getTransmission(isHighGear);
		final var ret = new Dynamics();

		ret.chassisVelocity = velocity;
		ret.curvature = ret.chassisVelocity.angular / ret.chassisVelocity.linear;

		if (Double.isNaN(ret.curvature)) {
			ret.curvature = 0.0;
		}

		ret.chassisAcceleration = acceleration;
		ret.dcurvature = (ret.chassisAcceleration.angular - ret.chassisAcceleration.linear * ret.curvature) / (ret.chassisVelocity.linear * ret.chassisVelocity.linear);

		if (Double.isNaN(ret.dcurvature)) {
			ret.dcurvature = 0.0;
		}

		ret.wheelVelocity = inverseKinematics(ret.chassisVelocity);
		ret.wheelAcceleration = inverseKinematics(ret.chassisVelocity);

		ret.torque = new WheelState(
				0.5 * wheelRadius * ((acceleration.linear * mass)
                        - (acceleration.angular * momentInertia / wheelBaseRadius)
                        - (velocity.angular * angularDrag / wheelBaseRadius)),
				0.5 * wheelRadius * ((acceleration.linear * mass)
                        + (acceleration.angular * momentInertia / wheelBaseRadius)
                        + (velocity.angular * angularDrag / wheelBaseRadius))
		);

		ret.voltage.left = transmission.voltageFromTorque(ret.wheelVelocity.left, ret.torque.left);
		ret.voltage.right = transmission.voltageFromTorque(ret.wheelVelocity.right, ret.torque.right);

		return ret;
	}

	public Dynamics solveInverseDynamics(final WheelState velocity, final WheelState acceleration, final boolean isHighGear) {
		return solveInverseDynamics(forwardKinematics(velocity), forwardKinematics(acceleration), isHighGear);
	}

	public double calculateMaxVelocity(final double curvature, final double maxVoltage, final boolean isHighGear) {
		final var transmission = getTransmission(isHighGear);
		final double freeSpeed = transmission.freeSpeedAtVoltage(maxVoltage);

		if (epsilonEquals(curvature, 0)) {
			return wheelRadius * freeSpeed;
		} else if (Double.isInfinite(curvature)) {
			return signum(curvature) * wheelRadius * freeSpeed / wheelBaseRadius;
		}

		final double rightConstrained = freeSpeed * (1.0 + wheelBaseRadius * curvature) / (1.0 - wheelBaseRadius * curvature);

		if (abs(rightConstrained) < freeSpeed) {
			return wheelRadius * (freeSpeed + rightConstrained) / 2.0;
		}

		final double leftConstrained = freeSpeed * (1.0 - wheelBaseRadius * curvature) / (1.0 + wheelBaseRadius * curvature);

		return wheelRadius * (freeSpeed + leftConstrained) / 2.0;
	}

	// Calculate the minimum and maximum forwards (linear) getAcceleration along the same curvature.
	// "curvature" must be consistent with "getVelocity" if getVelocity is nonzero.
	public Bounds calculateMinMaxAcceleration(
			final ChassisState velocity,
			final double curvature,
			final double maxVoltage,
            final boolean isHighGear
	) {
		final var transmission = getTransmission(isHighGear);
		final var result = new Bounds(Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY);

		final WheelState wheelVelocities = inverseKinematics(velocity);

		// Math:
		// (Tl + Tr) / r_w = m*a
		// (Tr - Tl) / r_w * r_wb - drag*w = i*(a * k + v^2 * dk)

		// 2 equations, 2 unknowns.
		// Solve for a and (Tl|Tr)

		final double linearTerm = Double.isInfinite(curvature) ? 0.0 : mass * wheelBaseRadius;
		final double angularTerm = Double.isInfinite(curvature) ? momentInertia : momentInertia * curvature;

		final double dragTorque = velocity.angular * angularDrag;

		// Check all four cases and record the min and max valid accelerations.
		for (final boolean left : Arrays.asList(false, true)) {
			for (final double sign : Arrays.asList(1.0, -1.0)) {
				final var wheelSpeed = left ? wheelVelocities.left : wheelVelocities.right;
				final double fixedTorque = transmission.torqueForVoltage(wheelSpeed, sign * maxVoltage);

				double variableTorque = 0.0;
				// NOTE: variableTorque is wrong.  Units don't work out correctly.  We made a math error somewhere...
				// Leaving this "as is" for code release so as not to be disingenuous, but this whole function needs
				// revisiting in the future...
                // its probably good enough lol
				if (left) {
					variableTorque = ((-dragTorque) * mass * wheelRadius + fixedTorque * (linearTerm + angularTerm)) / (linearTerm - angularTerm);
				} else {
					variableTorque = ((+dragTorque) * mass * wheelRadius + fixedTorque * (linearTerm - angularTerm)) / (linearTerm + angularTerm);
				}

				final double otherWheelSpeed = left ? wheelVelocities.right : wheelVelocities.left;

				final double variableVoltage = transmission.torqueForVoltage(otherWheelSpeed, variableTorque);

				if (abs(variableVoltage) <= maxVoltage + kEpsilon) {
				    final double acceleration;

					if (Double.isInfinite(curvature)) {
						acceleration = (left ? -1.0 : 1.0) * (fixedTorque - variableTorque) * wheelBaseRadius / (momentInertia * wheelRadius) - dragTorque / momentInertia;
					} else {
						acceleration = (fixedTorque + variableTorque) / (mass * wheelRadius);
					}

					result.min = min(result.min, acceleration);
					result.max = max(result.max, acceleration);
				}
			}
		}

		return result;
	}
}
